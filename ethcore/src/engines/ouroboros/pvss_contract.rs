use std::sync::Weak;
use client::{Client, BlockChainClient};
use util::*;
// TODO: cache
// use util::cache::MemoryLruCache;

pub struct PvssContract {
	pub address: Address,
    // TODO: cache
    // by_epoch: RwLock<MemoryLruCache<usize, PvssInfo>>,
	read_provider: RwLock<Option<provider::Contract>>,
    write_provider: RwLock<Option<provider::Contract>>,
}

impl PvssContract {
	pub fn new(address: &Address) -> Self {
		PvssContract {
			address: address.clone(),
			read_provider: RwLock::new(None),
            write_provider: RwLock::new(None),
		}
	}

	pub fn register_contract(&self, client: Weak<Client>) {
        let client1 = client.clone();
	    *self.read_provider.write() = Some(provider::Contract::new(self.address, move |a, d| {
            client1
			    .upgrade()
			    .ok_or("No client!".into())
			    .and_then(|c| {
                    c.call_contract(::client::BlockId::Latest, a, d)
                        .map_err(|e| format!("Transaction call error: {}", e))
                })
	    }));

    	*self.write_provider.write() = Some(provider::Contract::new(self.address, move |a, d| {
            client
			    .upgrade()
			    .ok_or("No client!".into())
			    .and_then(|c| {
                    c.transact_contract(a, d)
                        .map_err(|e| format!("Transaction call error: {}", e))
                        .map(|_| Default::default())
                })
	    }));
    }

	pub fn broadcast_commitments_and_shares(&self, epoch_number: usize, commitment_bytes: &[u8], share_bytes: &[u8]) {
		if let Some(ref provider) = *self.write_provider.read() {
			match provider.save_commitments_and_shares(epoch_number as u64, &commitment_bytes, &share_bytes) {
				Ok(_) => warn!(target: "engine", "Broadcast commitments and shares"),
				Err(s) => warn!(target: "engine", "Could not broadcast commitments and shares: {}", s),
			}
		} else {
			warn!(target: "engine", "Could not broadcast commitments and shares: no provider contract.")
		}
	}

    pub fn get_commitments_and_shares(&self, epoch_number: usize, address: &Address) -> Option<(Vec<u8>, Vec<u8>)> {
		if let Some(ref provider) = *self.read_provider.read() {

            match provider.get_commitments_and_shares(epoch_number as u64, address) {
                Ok((commitment_bytes, share_bytes)) => {
                    Some((commitment_bytes, share_bytes))
                },
				Err(s) => {
                    warn!(target: "engine", "Could not get commitments and shares: {}", s);
                    None
                },
			}
		} else {
			warn!(target: "engine", "Could not get commitments and shares: no provider contract.");
            None
		}
    }

	pub fn broadcast_secret(&self, epoch_number: usize, secret_bytes: &[u8]) {
		if let Some(ref provider) = *self.write_provider.read() {

			match provider.save_secret(epoch_number as u64, &secret_bytes) {
				Ok(_) => warn!(target: "engine", "Broadcast secret"),
				Err(s) => warn!(target: "engine", "Could not broadcast secret: {}", s),
			}
		} else {
			warn!(target: "engine", "Could not broadcast secret: no provider contract.")
		}
	}

    pub fn get_secret(&self, epoch_number: usize, address: &Address) -> Option<Vec<u8>> {
		if let Some(ref provider) = *self.read_provider.read() {
            match provider.get_secret(epoch_number as u64, address) {
                Ok(secret_bytes) => Some(secret_bytes),
				Err(s) => {
                    warn!(target: "engine", "Could not get secret: {}", s);
                    None
                },
			}
		} else {
			warn!(target: "engine", "Could not get secret: no provider contract.");
            None
		}
    }
}

mod provider {
    // Autogenerated from JSON contract definition using Rust contract convertor.
    #![allow(unused_imports)]
    use std::string::String;
    use std::result::Result;
    use std::fmt;
    use {util, ethabi};
    use util::{FixedHash, Uint};

    pub struct Contract {
    	contract: ethabi::Contract,
    	pub address: util::Address,
    	do_call: Box<Fn(util::Address, Vec<u8>) -> Result<Vec<u8>, String> + Send + Sync + 'static>,
    }
    impl Contract {
    	pub fn new<F>(address: util::Address, do_call: F) -> Self
    		where F: Fn(util::Address, Vec<u8>) -> Result<Vec<u8>, String> + Send + Sync + 'static {
    		Contract {
    			contract: ethabi::Contract::new(ethabi::Interface::load(b"[{\"constant\":false,\"inputs\":[{\"name\":\"epochIndex\",\"type\":\"uint64\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getCommitmentsAndShares\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epochIndex\",\"type\":\"uint64\"},{\"name\":\"secret_bytes\",\"type\":\"bytes\"}],\"name\":\"saveSecret\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epochIndex\",\"type\":\"uint64\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getSecret\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"epochIndex\",\"type\":\"uint64\"},{\"name\":\"commitment_bytes\",\"type\":\"bytes\"},{\"name\":\"share_bytes\",\"type\":\"bytes\"}],\"name\":\"saveCommitmentsAndShares\",\"outputs\":[],\"payable\":false,\"type\":\"function\"}]").expect("JSON is autogenerated; qed")),
    			address: address,
    			do_call: Box::new(do_call),
    		}
    	}
    	fn as_string<T: fmt::Debug>(e: T) -> String { format!("{:?}", e) }

    	/// Auto-generated from: `{"constant":false,"inputs":[{"name":"epochIndex","type":"uint64"},{"name":"sender","type":"address"}],"name":"getCommitmentsAndShares","outputs":[{"name":"","type":"bytes"},{"name":"","type":"bytes"}],"payable":false,"type":"function"}`
    	#[allow(dead_code)]
    	pub fn get_commitments_and_shares(&self, epoch_index: u64, sender: &util::Address) -> Result<(Vec<u8>, Vec<u8>), String>
    		 {
    		let call = self.contract.function("getCommitmentsAndShares".into()).map_err(Self::as_string)?;
    		let data = call.encode_call(
    			vec![ethabi::Token::Uint({ let mut r = [0u8; 32]; util::U256::from(epoch_index as u64).to_big_endian(&mut r); r }), ethabi::Token::Address(sender.clone().0)]
    		).map_err(Self::as_string)?;
    		let output = call.decode_output((self.do_call)(self.address.clone(), data)?).map_err(Self::as_string)?;
    		let mut result = output.into_iter().rev().collect::<Vec<_>>();
    		Ok(({ let r = result.pop().ok_or("Invalid return arity")?; let r = r.to_bytes().ok_or("Invalid type returned")?; r }, { let r = result.pop().ok_or("Invalid return arity")?; let r = r.to_bytes().ok_or("Invalid type returned")?; r }))
    	}

    	/// Auto-generated from: `{"constant":false,"inputs":[{"name":"epochIndex","type":"uint64"},{"name":"secret_bytes","type":"bytes"}],"name":"saveSecret","outputs":[],"payable":false,"type":"function"}`
    	#[allow(dead_code)]
    	pub fn save_secret(&self, epoch_index: u64, secret_bytes: &[u8]) -> Result<(), String>
    		 {
    		let call = self.contract.function("saveSecret".into()).map_err(Self::as_string)?;
    		let data = call.encode_call(
    			vec![ethabi::Token::Uint({ let mut r = [0u8; 32]; util::U256::from(epoch_index as u64).to_big_endian(&mut r); r }), ethabi::Token::Bytes(secret_bytes.to_owned())]
    		).map_err(Self::as_string)?;
    		call.decode_output((self.do_call)(self.address.clone(), data)?).map_err(Self::as_string)?;

    		Ok(())
    	}

    	/// Auto-generated from: `{"constant":false,"inputs":[{"name":"epochIndex","type":"uint64"},{"name":"sender","type":"address"}],"name":"getSecret","outputs":[{"name":"","type":"bytes"}],"payable":false,"type":"function"}`
    	#[allow(dead_code)]
    	pub fn get_secret(&self, epoch_index: u64, sender: &util::Address) -> Result<Vec<u8>, String>
    		 {
    		let call = self.contract.function("getSecret".into()).map_err(Self::as_string)?;
    		let data = call.encode_call(
    			vec![ethabi::Token::Uint({ let mut r = [0u8; 32]; util::U256::from(epoch_index as u64).to_big_endian(&mut r); r }), ethabi::Token::Address(sender.clone().0)]
    		).map_err(Self::as_string)?;
    		let output = call.decode_output((self.do_call)(self.address.clone(), data)?).map_err(Self::as_string)?;
    		let mut result = output.into_iter().rev().collect::<Vec<_>>();
    		Ok(({ let r = result.pop().ok_or("Invalid return arity")?; let r = r.to_bytes().ok_or("Invalid type returned")?; r }))
    	}

    	/// Auto-generated from: `{"constant":false,"inputs":[{"name":"epochIndex","type":"uint64"},{"name":"commitment_bytes","type":"bytes"},{"name":"share_bytes","type":"bytes"}],"name":"saveCommitmentsAndShares","outputs":[],"payable":false,"type":"function"}`
    	#[allow(dead_code)]
    	pub fn save_commitments_and_shares(&self, epoch_index: u64, commitment_bytes: &[u8], share_bytes: &[u8]) -> Result<(), String>
    		 {
    		let call = self.contract.function("saveCommitmentsAndShares".into()).map_err(Self::as_string)?;
    		let data = call.encode_call(
    			vec![ethabi::Token::Uint({ let mut r = [0u8; 32]; util::U256::from(epoch_index as u64).to_big_endian(&mut r); r }), ethabi::Token::Bytes(commitment_bytes.to_owned()), ethabi::Token::Bytes(share_bytes.to_owned())]
    		).map_err(Self::as_string)?;
    		call.decode_output((self.do_call)(self.address.clone(), data)?).map_err(Self::as_string)?;

    		Ok(())
    	}
    }
}
